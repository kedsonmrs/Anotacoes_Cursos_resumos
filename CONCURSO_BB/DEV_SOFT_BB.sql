ALGORITMOS DE ORDENAÇAO
	ALGORITMO ESTAVEL /* AO ORDENAR OS NUMEROS, ELE NAO TROCA OS IGUAIS */
	ALGORITMO INSTAVEL /* ELE TROCA OS IGUAIS */

	COMPLEXIDADE DE UMA ALGORITMO /* CUSTO OPERACIONAL */
		BIG O NOTATION /* TIPOS DE CRESCIMENTO DE CUSTO */
		O(n!) -> O(2^n) -> O(n^3) -> O(n^2) -> O(n log n) -> O(n) -> O(log n) -> O(1)
	
	MENOS EFICIENTES !
		BUBBLE SORT /* + COBRADO + SIMPLES */ !! TROCA COM ELEMENTOS ADJACENTES !!
			COMPLEXIDADE /* PIOR/MEDIO CASO = On^2 - MELHOR CASO On */
											/* COM FLAG DE NENHUMA TROCA */
		
		SELECTION SORT /* NAO USA ESTRUTURA AUXILIAR */ 
			POUCO EFICIENTE /* POIS VARRE SEMPRE TODOS OS ITENS DA ARRAY */
			/* VARRE TODA A ARRAY PARA VER O MENOR E DEPOIS SETA NO LUGAR CORRETO */
			COMPLEXIDADE /* On^2 TODOS OS CASOS */
		
		INSERTION SORT
			COMPLEXIDADE /* PIOR/MEDIO CASO On^2 - MELHOR On */
			/* A MEDIDA QUE AVANÇA ORDENA OS ELEMENTOS A ESQUERDA */
			/* UTILIZA UMA VARIAVEL DE AUXILIAR PARA ORDENAÇAO (O(1)) */
		
			SHELL SORT /* OTIMIZAÇAO DO INSERTION SORT */
				COMPLEXIDADE /* PIOR CASO On^2 - MELHOR Onlogn - MEDIO DEPENDE DO GAP */
				/* PERMITE TROCA ENTRE ELEMENTOS DISTANTES UM DO OUTRO */
				!!O MAIS EFICIENTE DOS On^2 /* GAP - distancia entre elementos */
				/* VAI DIMINUINDO O GAP A CADA VARREDURA */
	
	MAIS EFICIENTES
		
		QUICK SORT /* DIVIDIR PARA CONQUISTAR */
			COMPLEXIDADE /* PIOR On^2 - MEDIO/MELHOR Ologn */
				ESCOLHE O PIVOT /* QUALQUER NUMERO DA LISTA */
				ORDENA-SE COM RELAÇAO A ELE /* MAIOR/ MENOR QUE ELE */
				FIXA ELE E ORDENA-SE OS DOIS LADOS ENTRE SI /* FAZ-SE DE FORMA PARALELIZADA */
					OBS /* A ORDENAÇAO OCORRE TAMBEM EM QUICK SORT ATE ORDENAR TUDO */

		MERGE SORT 
			COMPLEXIDADE /* Onlogn - TODOS OS CASOS */
			UTILIZA VETOR AUXILIAR /* MAIS MEMORIA */
			!! TAMBEM DIVIDE !! /* RESOLVE CADA PEDAÇO E DEPOIS JUNTA (MERGE) OS RESULTADOS */
		
		HEAP SORT /* UTILIZADA ESTRUTURA AUXILIAR (ARVORE BINARIA) */	
			COMPLEXIDADE /* Onlogn TODOS */
			MAIS EFICIENTE DE TODOS
	
	BIZU!!!!! COMO CAI
		1-CARACTERISTICAS 2-COMPLEXIDADES 3-N DE TROCAS 4-IMAGENS(RECONHECER)
		5- LER O ALGORITMOS
		
ESTRUTURA DE DADOS
	TAD (TIPO DE DADO ABSTRATO) /* ESTRUTURA DE DADOS NA QUAL É POSSIVEL FAZER OPERAÇOES */
		OPERAÇOES 
			- ADIÇAO DE ELEMENTOS
			- REMOÇAO
			- ATUALIZAÇAO
			- PESQUISA

		LIST /* ACESSO AO ELEMENTO VIA INDICE */
			/* PERMITE ELEMENTOS REPETIDOS */
			/* MANTEM ORDEM DE INSERÇAO */
			
			LISTA ENCADEADA /*LISTA A QUAL ARMAZENA O VALOR E O INDEX DO PROXIMO VALOR */
				- MENOS MEMORIA 
				- A INSERÇAO E RAPIDA
				- MAIS LENTA NA REMOÇAO DOS ELEMENTOS NOS FINAIS
				
			DUPLAMENTE ENCADEADA /* ARMAZENA O INDEX DO VALOR ANTERIOR E O APOS */
				- COMEÇA POR QUALQUER LADO
				- GASTA MAIS MEMORIA
				- COSTUMA TER MELHOR PERFORMANCE
			
			CIRCULAR /* O ULTIMO ELEMENTO TEM A REFERENCIA DO PRIMEIRO */
			
		SET /* NAO ACEITA ELEMENTOS REPETIDOS */
			/* NAO MANTEM A ORDEM DE INSERÇAO */
			/* NAO HA O ACESSO VIA INDICE */
			! IDEAL PARA OPERAÇOES DE CONJUNTOS 
	
		MAP /* DICT - ASSOCIAÇAO */
			/* POSSUI CHAVE/VALOR */
			! CHAVE NUNCA REPETE, VALOR REPETE !
			! HASH USA !
	
	PILHA /* ARMAZENAGEM LITERALMENTE EM PILHA */
		- LIFO /* PRIMEIRO A ENTRAR É O ULTIMO A SAIR */
			EX: 1 - 2 - 3 - 5 (> 5 - 3 - 2 - 1
		
		- PUSH /* COLOCAR DADOS */
		- POP /* RETIRAR DADOS */
		- PEEK /* VERIFICAR CABEÇA DA PILHA */
	
	FILA /* EM FILA INDIANA */
		- FIFO /* PRIMEIRO ENTRA ENTAO PRIMEIRO SAI = ORDEM IGUAL NA SAIDA */
			EX: 1 - 2 - 3 - 6 - 7 (> 1 - 2 - 3 - 6 - 7
		
		- ENQUEUE /* ENFILEIRAR - ENTRADA */
		- DEQUEUE /* DESENFILEIRAR - SAIDA */
	
	ARVORE
		- IDEAL PARA REPRESENTAR HIERARQUIA
		- MAIS EFICIENTE QUE LISTAS
		- ARVORES BINARIAS /* ZERO, UM OU DOIS FILHOS (NOS) */
		- ARVORE ESTRITAMENTE BINARIAS /* 0 ou 2 FILHOS(NOS) */
		
		RAIZ /* NO PRINCIPAL, PRIMEIRO NO */
		FOLHA /* NO SEM FILHOS */
		GRAU /* NUMERO DE FILHOS */
		PROFUNDEIDADE DE UM NO /* DISTANCIA DESTE NO ATE A RAIZ */
		
		COMPLEXIDADE
			-ESPAÇO /* MEDIO CASO - O(n) PIOR CASO - O(n) */
			-BUSCA /* MEDIO CASO - O(logn) MELHOR CASO '' */
			-INSERÇAO ''
			-REMOÇAO ''
		
		ARVORE BALANCEADA - ARVORE B, B+
			-AVL - de Adelson-Velsky e Landis /* ARVORE BINARIA DE BUSCA */
			-BALANCEADA /* ORDENA CONFORME INSERE OS DADOS */
			-DIFERENÇA ENTRE LADOS DA RAIZ MAX 1 
			-USADA EM /* bancos de dados e sistemas de arquivos */
		
		!! COMO PERCORRER A ARVORE !!
			PRE-ORDEM = RAIZ - ESQUERDA - DIREITA
			ORDEM = ESQUERDA - RAIZ - DIREITA
			POS-ORDEM = ESQUERDA - DIREITA - RAIZ
		
		ARVORE CHEIA /* TODOS COM 2 FILHOS (eXCETO ULTIMOS) */
		ARVORE COMPLETA /* NEM TODOS TEM 2 FILHOS */
	
		PARA SABER ALTURA DA ARVORE /* LOG2(n+1) - 1 começando 0 */
									/* LOG2(n+1) começando 1 */
		
	PESQUISA SEQUENCIAIS /* MAIS SIMPLES, VARRE DE UM POR UM */
		- RUIM PARA DATASET GRANDE
		- PIOR CASO O(n)
		- MELHOR - O(1)
		- MEDIO O(1+n)/2
		
	PESQUISA BINARIA
		- ACESSO ALEATORIO A ELEMENTOS
		- PARTE DA PREMISSA QUE JA ESTA ORDENADO /* DIREITA MAIOR QUE A RAIZ, ESQUERDA MENOR, SEMPRE */
		- DIVIDE O VETOR NO ELEMENTO CENTRAL
			/* DIVIDE PARA CORTAR PELA METADE A BUSCA, SE MAIOR VARRE A DIREITA E SE MAIOR A ESQUERDA */
		
		- !!! ARRAY COM NUMEROS INTEIROS !!!	
			
		- COMPLEXIDADE
			- MELHOR CASO  O(1)
			- MEDIO CASO O(logn)
			- PIOR CASO O(logn)		